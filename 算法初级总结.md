# 算法初级中涉及的数据结构和算法总结
[TOC]



## 线性结构

### 数组
使用**顺序存储**方式实现

* 读取：时间复杂度为o(1)
* 查找：时间复杂度为o(n) 
	* 从索引为0开始查找元素，找到就停止查找。 
    
* 插入：时间复杂度为o(n)
	* 中间插入时，需要从想要插入的位置开始向后移动，空出位置插入新值。
		* 插入第一个元素时，需要移动n次。
	* 末尾插入时，只需要计算添加的内存地址即可	 	
* 删除：时间复杂度为o(n)
	* 当删除一个元素后，后面的元素要向前移动填补空位

> **数组频繁的插入会造成时间上的浪费，最好使用链表。**

### 链表
使用 **链式存储**方式实现

* 读取：时间复杂度为o(n)
	* 想要访问某个元素，必须要从头节点开始遍历，通过next属性找到下一个节点，直到找到为止。n为链表长度，最多需要遍历n次。
* 查找：时间复杂度为o(n)
* 插入：时间复杂度为o(1)
* 删除：时间复杂度为o(1)

> **总结：**
> 链表结构更适合需要频繁插入和删除操作的数据处理。

### 栈和队列
栈是先进后出（LIFO）
队列是先进先出（FIFO)

#### 优先队列
> 待补充

#### 与数组和链表的区别
* **栈和队列可以用数组或链表实现。**
* 数组 和 链表 主要描述了数据是如何存储的，和存取方式无关。
* 而栈和队列是对数据的存取方式作了特殊的规定，是一种更抽象的数据结构


## 树
是一种具有树状结构的集合

### 二叉树
树中的结点最多只能有两个子树的树状结构。通常称为左子树和右子树。

* 二叉树可以使用链式的方式存储。每个结点对象中都有left和right两个指针指向左右子结点。
* 二叉树也可以用数组的方式存储。在堆排序中，就是将数组想象成一个堆结构。
* 二叉树相关的算法题中（简单）可以使用 
	* BFS算法
		* 使用 迭代 + 队列方式实现。具体的代码中使用while循环实现迭代，在while循环体中 先取出数组头部元素，进行逻辑运算，根据条件判断决定是否向数组尾部增加元素，以此实现了队列的先进先出特性。
		* 时间复杂度通常为 o(n), 因为可能要遍历树中的所有结点
		* 空间复杂度通常为 o(n), 队列占用的空间大小和树中的结点数量有关。
	* DFS算法
		* 使用 递归 + 栈 方式实现。


#### 完全二叉树
除了最后一层的右边，其他节点都已填满

#### 堆
满足以下两个条件的二叉树就是堆
* 完全二叉树
* 每个节点的值总是大于等于其子节点的值（最大堆）； 或者小于等于其子节点的值（最小堆）

##### 特点
* 读取最大或最小值：
	* 时间复杂度为 O(1)
* 插入元素
	* 时间复杂度为 O(logN) 
* 删除元素 
	* 时间复杂度为 O(logN) 

## 散列表（哈希表）

哈希表具有唯一特性

哈希集合
	Set
	
哈希映射
	Map


-----


# 算法

DFS

BFS

分治思想

二分法


# 技巧

双指针

快慢指针

# 实际问题类型
动态规划


# 其他

## 递归


### 时间复杂度的计算
* 递归调用的数量 乘以 每层递归函数中的时间复杂度。

#### 如何分析递归调用的数量？
使用**执行树**分析。
> 执行树是用于表示递归函数的执行流程的树。树中的每个节点都表示递归函数的调用。因此树中的节点总数对应于执行期间的递归调用的数量

**举例：**
* 斐波那契数列 在暴力解法中, 斐波那契数列函数的执行将形成**二叉树**
* 在n层的完全二叉树中，节点的总数为2^n -1。那么时间复杂度的上限就是O(2^n)

**举例：**
* 归并排序递归解法的时间复杂度就是: O（NlogN)
	* 递归调用的数量为 logN
	* 每层递归函数的时间复杂度为 O(N) 

* 可以使用Memorization（记忆化）技术 来降低时间复杂度
**举例：**
* 斐波那契数列可以使用一个全局的Map类型对象用于记录重复计算的结果。这样时间复杂度可以降低至O(N)



### 空间复杂度的计算
需要考虑以下两点：
1. 由递归直接引起的内存开销，就是用于跟踪递归函数调用的**堆栈**。
	系统会在栈中分配一些空间来保存三个重要信息
	* 函数调用的返回地址
	* 传递给函数调用的参数
	* 函数调用中的局部变量
2. 非递归相关空间
	不是在递归函数内部分配的空间。
	通常包括为全局变量分配的空间
	比如在Memorization（记忆化）	技术中，设定全局变量用于保存递归调用的中间结果。

> 总结：
> 递归导致的堆栈内存开销，需要分析一共调用了多少层的递归函数，层数即为空间复杂度
> 非递归相关空间通常是常数级别，所以一般情况下空间平均复杂度都是由堆栈内存开销决定的。

### 尾递归



## 迭代


> 总结：
> 递归是自顶向下，迭代是自下向上
> 





