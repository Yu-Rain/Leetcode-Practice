# 53. 最大子序和 (简单)

> [leetcode地址](https://leetcode-cn.com/problems/maximum-subarray/)

## 题目描述
给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

示例 1：
```
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
```

示例 2：
```
输入：nums = [1]
输出：1
```
示例 3：
```
输入：nums = [-1]
输出：-1
```

> 提示：
	•	`1 <= nums.length <= 3 * 104`
	•	`-105 <= nums[i] <= 105`


**进阶**：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。

------

## 方案1: 动态规划

* 属于**线性动态规划**类问题
* 可以使用数组中 每次减少一个 的方式减小问题规模（就是拆分子问题）
* 确定状态 f(i) (代表子问题最优解)
	* f(i)为以第i个数结尾的最大子序和
	* `0 <= i <= n-1`
* 确定状态转移方程（也就是子问题最优解的组合方式）
	* 最终问题规模会减少到数组中只有一个元素，下标为`0`，此时`f(0)`为 `nums[0]`
	* 然后下标为 `1` 的最大子序和的计算过程为
		* 首先 `f(0) + nums[1]` 得到 新的连续子序和,我们先暂时称为 `T(1)` 
		* 然后 `T(1)` 和 `nums[1]` 进行比较，取较大值
			* 如果`nums[1]`是负数，`T(1)` 就会小于 `nums[1]`, 那么`f(1)`就为 `nums[1]`
			* 如果`nums[1]`是正数，`T(1)` 就会大于 `nums[1]`, 那么`f(1)`就为 `T(1)`
		
	* 通过以上分析，状态转移方程为 `f(i) = max(f(i-1) + nums[i], nums[i])`

* 组合子问题最优解
	* 比较所有子问题的最优解，找到最大值 
	* 实现方案
		* 使用数组记录对应下标的 f(i), 最后从数组中得到最大值。这种实现的空间复杂度为O(N)
		* 使用全局变量记录 当前已知子问题最优解的最大值。每次计算出子问题最优解，都与当前最大值进行比较。 这种实现的空间复杂度为O(1)


### 代码实现方案1：迭代 （自底向上）

* 确定状态转移方程的分析过程就是自底向上的。从最小规模问题入手，逐步增加问题规模，直到所求的问题规模
* 使用for循环从下标0开始遍历，循环体内过程参考 确定状态转译方程的分析过程  
* 使用全局变量的方式组合最优解

* 时间复杂度：O(N), N为数组长度
* 空间复杂度：O(1), 只使用了常数的变量空间

```js
var maxSubArray = function(nums) {
    
    let prev = nums[0];
    let maxSum = nums[0];
    for (let i = 1; i < nums.length; i++) {
        // 计算以当前下标为结尾的连续子序和.
        const T1 = prev + nums[i];
        // 计算以当前下标为结尾的最大连续子序和, 并记录在prev变量中, 提供给下一次循环计算使用.
        prev = Math.max(T1, nums[i]);
        // 计算当前已知子问题中的最大连续子序和, 记录在masSum变量中.
        maxSum = Math.max(maxSum, prev);
    }

    return maxSum;
};

```



### 代码实现方案2：递归 （自顶向下）

> 待补充
	
	
	 	

